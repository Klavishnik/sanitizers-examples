# Безопасное программирование

Тут буду описывать основные подходы к безопасному программированию.

Будет постепенно обновляться.

Версия от 11.09.2023


## Компилируем правильно
### Как делаем обычно:
Компиляция программы это процесс получения из исходного кода исполняемого файла. 

Обычно делается вот так:

```
gcc main.c
```

Где `main.c` ваш файлик с исходным кодом.

Если вы выполнили эту команду и компилятор ничего Вам не написал, то с небольшой вероятностью банальных ошибок вы избежали. 
В целом это хорошая история, значит Ваша программа смогла собраться в исполняемый файл.

Но бывают ситуации, когда комплятор может **что-то** вывести. 

Это **что-то** может быть двух видов:

1. Warning (предупрждения) (подсвечивается желтым) - компилтор предупреждает Вас, что вы скорее всего делаете что-то неправильно (небезопасно), но программу скомпилировать даст. 
  **Настоятельно НЕ рекомендую их игнорировать**
2. Error (ошибка) (подсвечивается красным) - вы где-то сильно накосячили, скорее всего в синтаксисе языка, причем так, что это не дает скомпилровать программу. 

Тут придется все исправлять, иначе исполняемый файл Вы не получите.

### Как нужно делать правильно:
Во-первых, компилятор **ВАШ ДРУГ**. В нем есть встроенный синтаксический и (немного) статический анализаторы кода. 
Т.е. на этапе копиляции он анализирует Ваш код. Если он что-то нашел, то лучше это исправить.

Но стандартные паттерны определения небезопасных коснтрукций достаточно ограничены. 
Чтобы расширить их добавьте два флага при компиляции

1. `-Wall`  (short for "all warnings") включает все стандартные предупреждения компилятора. Этот флаг полезен, чтобы быть уверенным, что все потенциально проблемные участки кода будут выявлены.
Например, флаг -Wall может предупредить о неиспользуемых переменных, неинициализированных переменных, некорректных вызовах функций и так далее.
2. `-Wextra` (short for "extra warnings") включает дополнительные предупреждения, кроме тех, которые включает флаг -Wall.
Этот флаг активирует дополнительные предупреждения компилятора, такие как предупреждение о неиспользуемых аргументах функций, предупреждение о несоответствии типов указателей, предупреждение о сравнении разных типов и так далее.

Т.е. Ваша команда компиляции начинает выглядеть вот так:

```
gcc -Wall -Wextra main.c
```

Это приводит к большему выводу ошибок и предупреждений, что хорошо - вы УЖЕ нашли ошибку и можете её исправить, а не попали на неё во время сдачи кода и судорожно пытаетесь пофиксить.

### Что добавить до идеала:

Выше писал, что нужно исправлять даже предупреждения, поскольку код не такой сложный?

Сделаем это на уровне флага - добавим флаг `-Werror`. 

Этот флаг заставляет компилятор воспринимать все предупреждения, как ошибки. 

Т.е. даже с предупреждением код не скомпилируется.

Итоговая команда компиляции кода:

```
gcc -Wall -Wextra -Werror main.c
```


## Числа, цифры и операции с ними

В ходе первых двух лаб вы оперируете числами. 

Основные ошибки при работе - переполнение типа данных и деление на ноль. 

### Про переполнеине разрядной сетки

Пусть у нас число размером 1 байт (8 бит), знаковое.

Тогда число 127 будет выглядеть так:
```
0111 1111
```


0 - это старший байт и он отвечает за знак. 
0 - положительное, 1 - отрицательное.

Если сделать 127 + 1, то получится не 128, а -128. 

Почему?

Потому что:
```
0111 1111
0000 0001
---------
1000 0000
```

Старший бит отвечает за знак, остальные за само число. 
И так мы получили из максимума минимум. 

Вы прекрасны, мои поздравления.

**За подробностями на курс по ЭВМ.**

## Как определить

Использовать флаг компилятора `-ftrapv`.

Он встраивает ассемблерные инструкици в Ваш код, которые проверяют числа после арифметических операций.

Если что-то пошло не так, то он завершит Вашу программу с надписью "Abort".

Никакой диагностической информации.

Просто сам факт наличия ошибки.

## Как отладить?

Использовать санитайзер кода UBSAN.

Undefined Santizer - Санитайзер, который определяет неопределенное поведение

Если ошибку поймали, то будет вывод хоть немного подробный.

Как использовать?

На этапе компиляции добавить флаги:

`-g` - флаг, подключающий отладочную информацию.

`-fsanitize=undefined` - флаг санитайзеры

Итого, команда компиляции:

```
clang -g -fsanitize=undefined main.c 
```

С `-ftrapv` не смешивать.

clang - просто другой компилятор. Флаги такие же как для gcc.


### Пример

Есть вот такой код

```int_overflow.c
#include <limits.h>
#include <stdio.h>

int main() {
    int max_value = INT_MAX;
    int reuslt = max_value * max_value;
    printf("%i", max_value);
    return 0;
}
```

Компилим, запускаем:

```
gcc int_overflow.c
./a.out
```
Получаем число без ошибокю

А если так:

```
clang -g -fsanitize=undefined int_overflow.c
./a.out
```

Вот вывод:

```
int_overflow.c:6:28: runtime error: signed integer overflow: 2147483647 * 2147483647 cannot be represented in type 'int'
SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior int_overflow.c:6:28 in 
```

`int_overflow.c:6:28` - на шестой строке файла int_overflow.c произошло переполнение типа данных int.

Далее описание того, на каких значениях пошли проблемы.

На второй строке - типизация ошибки. У нас это  "неопределенное поведение".


# Переполнение на вводе
У многих возникает вопрос, как отслеживать переполнение на вводе. 
Начнем с того, что "переполнение на вводе" это вообще некорректный термин. 
Переполнение типа данных может возникнуть только при каких-то манипуляциях над переменными (например, инкрементация).
Такие переполнения можно ловить с помощью санитайзера `UBSAN` или флага компиляции `-ftrapv`. 

## Как появляется?
При вводе числа большего, чем диапазон выбранного типа данных (например, `int`), оно просто откинет старшие байты числа.
Например для `int` максимальное количество цифр, которое можно ввести - 10. Если вы введете 12, то старшая часть числа (в двоичной системе счисления) откинется. 

Пример. Есть число:
```
(dec) 123 456 789 123
(bin) 0001 1100 1011 1110 1001 1001 0001 1010 1000 0011
```

Это число занимает 5 байт, в int влезет всего 4. 
Т.е. старшие 8 бит откидываются и в переменную у нас запишется число:
```
(bin) 1011 1110 1001 1001 0001 1010 1000 0011
(dec) 1 050 221 187
```

Как видим, здесь даже не изменился знак числа.
Т.е. отследить это будет крайне сложно. 

## А как sacnf данные получает?
В системе есть несколько потоков - поток ввода (`stdin`), вывода (`stdout`) и ошибок (`stderr`). 
Поток ввода берет данные со стандартного устройства ввода (по умолчанию это клавиатура) и хранит его в буфере из которого уже `scanf()` примет данные.

Вопрос - если мы не смогли считать данные за один раз, значит ли что оставшиеся данные будут храниться в буфере `stdin`? 

Ответ - да.


Вопрос - значит ли, что мы может вызвать функцию `scanf()` дважды, чтобы она забрала из буфера оставшиеся данные?

Ответ - нет. Второй `scanf()` заставит дописать данные в буфер. Это затрет старый набор данных, который хранился в буфере ввода. 


## А как избежать потери данных?

Есть два способа:
1) Объявите переменную бОльшего диапазона данных, через которую будете контролировать данные.
Например, для `int` создайте вторую переменную с типом данных `long int` и записывайте ввод в неё. 
Далее, через обычный `if` контролируйте введённое число. Если оно больше диапазона `int'a` - выкидывайте ошибку. Меньше - продолжайте работу.
Этот способ не убережет Вас от ситуации, когда будет введено число, превышающее диапазон `long int`. 

2) Использовать спецификатор ввода. 
Конструкция `scanf("%5i",&input)`; считает только 5 символов.
Не забудете написать предупреждение для пользователя.




## Контакты автора
С Вами был Евгений Штанов

https://t.me/Klavishnik0_o 

Успехов


